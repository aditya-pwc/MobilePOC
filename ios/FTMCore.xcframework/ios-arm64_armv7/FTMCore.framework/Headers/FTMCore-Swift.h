#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.3 (swiftlang-1200.0.29.2 clang-1200.0.30.1)
#ifndef FTMCORE_SWIFT_H
#define FTMCORE_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreBluetooth;
@import CoreLocation;
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="FTMCore",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif


/// A Footmarks beacon.
SWIFT_CLASS("_TtC7FTMCore9FTMBeacon")
@interface FTMBeacon : NSObject
/// The accuracy of the underlying <code>CLBeacon</code>.
@property (nonatomic, readonly) CLLocationAccuracy accuracy;
/// The attributes configured on the management console.
/// Attributes are a flexible way to specify metadata for a beacon. They can be used as
/// filters when finding the nearest beacon.
/// seealso:
///
/// <code>FTMNearestBeaconRequest.begin(attributeFilterKey:attributeFilterValue:completion:)</code>
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nonnull attributes;
/// The hash value.
@property (nonatomic, readonly) NSUInteger hash;
/// The unique identifier for the beacon.
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
/// The MAC address.
@property (nonatomic, readonly, copy) NSString * _Nonnull macAddress;
/// The name of the beacon.
/// Generally the name will be the same as the beacon’s <code>macAddress</code>, although beacon names
/// can be customized on the management console.
@property (nonatomic, readonly, copy) NSString * _Nonnull name;
/// The proximity of the underlying <code>CLBeacon</code>.
@property (nonatomic, readonly) CLProximity proximity;
/// The RSSI value of the underlying <code>CLBeacon</code>.
@property (nonatomic, readonly) NSInteger rssi;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@protocol FTMBeaconManagerDelegate;

/// The beacon manager, which maintains a list of in-range beacons and communicates state changes
/// with its delegate.
SWIFT_CLASS("_TtC7FTMCore16FTMBeaconManager")
@interface FTMBeaconManager : NSObject
/// All beacons that are in range of the current device.
/// When entering a region, one or more beacons are added to the set, and when exiting a region
/// they are removed. Changes can be monitoried by implementing
/// <code>FTMBeaconManagerDelegate.beaconManagerDidRangeBeacons()</code>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSSet<FTMBeacon *> * _Nonnull beacons;)
+ (NSSet<FTMBeacon *> * _Nonnull)beacons SWIFT_WARN_UNUSED_RESULT;
/// The state of the underlying <code>CBCentralManager</code>.
/// Changes can be monitoried by implementing
/// <code>FTMBeaconManagerDelegate.beaconManagerDidUpdateCentralManagerState()</code>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) CBManagerState centralManagerState;)
+ (CBManagerState)centralManagerState SWIFT_WARN_UNUSED_RESULT;
/// The delegate.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, weak) id <FTMBeaconManagerDelegate> _Nullable delegate;)
+ (id <FTMBeaconManagerDelegate> _Nullable)delegate SWIFT_WARN_UNUSED_RESULT;
+ (void)setDelegate:(id <FTMBeaconManagerDelegate> _Nullable)value;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// A delegate for communicating beacon related updates and state changes.
SWIFT_PROTOCOL("_TtP7FTMCore24FTMBeaconManagerDelegate_")
@protocol FTMBeaconManagerDelegate
@optional
/// Called when the underlying <code>CLLocationManager</code> changes its authorization status.
/// Call <code>CLLocationManager.authorizationStatus()</code> to retrieve the status. An app might update
/// its user interface in response to a status change, for example.
- (void)beaconManagerDidChangeLocationManagerAuthorizationStatus;
@required
/// Called when the beacon manager experiences an error.
/// If the error’s domain matches <code>FTMError.domain</code>, the error code can be comapred to one of
/// the <code>FTMError</code> enumeration values.
- (void)beaconManagerDidFailWithError:(NSError * _Nonnull)error;
/// Called when the beacon manager updates its beacons.
/// Beacons are updated when entering a region, when idling within in a region, and when exiting
/// a region. The latest beacons are available by calling <code>FTMBeaconManager.beacons</code>.
- (void)beaconManagerDidRangeBeacons;
@optional
/// Called when the underlying <code>CBCentralManager</code> updates its state.
/// Call <code>FTMBeaconManager.centralManagerState</code> to retrieve the state. An app might update
/// its user interface in response to a state change, for example.
- (void)beaconManagerDidUpdateCentralManagerState;
@end

/// An enumeration of error codes associated with errors returned by the framework.
typedef SWIFT_ENUM(NSInteger, FTMError, closed) {
/// The app key or secret is missing from
/// <code>FTMSession.signIn(appKey:appSecret:globalRegion:username:completion:)</code>
  FTMErrorAppKeyOrSecretMissing = 0,
/// Authorization failed during a network request.
  FTMErrorAuthFailed = 1,
/// The required <code>NSBluetoothAlwaysUsageDescription</code> key is missing from the app’s
/// plist file.
  FTMErrorBluetoothAlwaysUsageDescriptionMissing = 2,
/// The required <code>NSBluetoothPeripheralUsageDescription</code> key is missing from the app’s
/// plist file.
  FTMErrorBluetoothPeripheralUsageDescriptionMissing = 3,
/// The NFC messages can’t be handled.
  FTMErrorCannotHandleNFCMessages = 4,
/// The required <code>NSLocationAlwaysAndWhenInUseUsageDescription</code> key is missing from the app’s
/// plist file.
  FTMErrorLocationAlwaysAndWhenInUseUsageDescriptionMissing = 5,
/// The required <code>NSLocationAlwaysUsageDescription</code> key is missing from the app’s plist file.
  FTMErrorLocationAlwaysUsageDescriptionMissing = 6,
/// The use of location services has not been granted.
  FTMErrorLocationServicesDenied = 7,
/// Location services are disabled.
  FTMErrorLocationServicesDisabled = 8,
/// The required <code>NSLocationWhenInUseUsageDescription</code> key is missing from the app’s plist file.
  FTMErrorLocationWhenInUseUsageDescriptionMissing = 9,
/// A parameter has an invalid value.
  FTMErrorParameter = 10,
/// A miscellaneous error occurred while making a network request.
  FTMErrorWebServiceGeneric = 11,
};

enum FTMExperienceEngagement : NSInteger;
enum FTMExperienceType : NSInteger;
@class NSCoder;
enum FTMExperienceAction : NSInteger;
enum FTMExperienceValueType : NSInteger;
@class FTMRequestHandle;

/// An experience configured in the SmartConnect Cloud.
SWIFT_CLASS("_TtC7FTMCore13FTMExperience")
@interface FTMExperience : NSObject <NSSecureCoding>
/// The attributes of the payload as configured on the management console.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nonnull attributes;
/// The content of the experience.
/// The nature of the content depends on the experience type.
/// <ul>
///   <li>
///     alert: (unused)
///   </li>
///   <li>
///     custom: Any custom value
///   </li>
///   <li>
///     html: The HTML
///   </li>
///   <li>
///     image: The image URL
///   </li>
///   <li>
///     url: The URL
///   </li>
///   <li>
///     video: The video URL
///   </li>
/// </ul>
@property (nonatomic, readonly, copy) NSString * _Nonnull content;
/// The type of engagement to have with the user.
@property (nonatomic, readonly) enum FTMExperienceEngagement engagement;
/// The type of experience.
@property (nonatomic, readonly) enum FTMExperienceType experienceType;
/// The hash value.
@property (nonatomic, readonly) NSUInteger hash;
/// The name of the payload as configured on the management console.
@property (nonatomic, readonly, copy) NSString * _Nonnull name;
/// The description when <code>engagement</code> is of type <code>prompt</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull promptDescription;
/// The title when <code>engagement</code> is of type <code>prompt</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull promptTitle;
/// Supports secure coding.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
+ (void)setSupportsSecureCoding:(BOOL)value;
/// Creates an experience using the given unarchiver.
/// \param decoder An unarchiver object.
///
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// Encodes the experience using the given archiver.
/// \param encoder An archiver object.
///
- (void)encodeWithCoder:(NSCoder * _Nonnull)encoder;
/// Sends a conversion to the SmartConnect Cloud to acknowledge that the experience has been
/// received and processed.
/// \param action The action that was taken.
///
/// \param valueType The type of the value.
///
/// \param value The value associated with the conversion.
///
/// \param completion The completion handler.
///
///
/// returns:
///
/// A request handle.
- (FTMRequestHandle * _Nonnull)sendConversionWithAction:(enum FTMExperienceAction)action valueType:(enum FTMExperienceValueType)valueType value:(double)value completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Sends a conversion to the SmartConnect Cloud to acknowledge that the experience has been
/// received and processed.
/// \param customActionName The name of the custom action that was taken.
///
/// \param customValueName The name of the custom value.
///
/// \param value The value associated with the conversion.
///
/// \param completion The completion handler.
///
///
/// returns:
///
/// A request handle.
- (FTMRequestHandle * _Nonnull)sendConversionWithCustomActionName:(NSString * _Nonnull)customActionName customValueName:(NSString * _Nonnull)customValueName value:(double)value completion:(void (^ _Nullable)(NSError * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// The action taken for the experience conversion.
typedef SWIFT_ENUM(NSInteger, FTMExperienceAction, closed) {
/// The conversion happened automatically.
  FTMExperienceActionAutomated = 0,
/// The content was tapped or clicked.
  FTMExperienceActionClicked = 1,
/// The content was listened to.
  FTMExperienceActionListened = 2,
/// No action was taken.
  FTMExperienceActionNone = 3,
/// The content was opened.
  FTMExperienceActionOpened = 4,
/// The content was retargeted.
  FTMExperienceActionRetargeted = 5,
/// The content was shared.
  FTMExperienceActionShared = 6,
/// The content was swiped.
  FTMExperienceActionSwiped = 7,
/// The content was watched.
  FTMExperienceActionWatched = 8,
};

/// The engatement types for experiences.
typedef SWIFT_ENUM(NSInteger, FTMExperienceEngagement, closed) {
/// When the experience is delivered, it is meant to be presented immediately.
  FTMExperienceEngagementAutoShow = 0,
/// When the experience is delivered, no engagement with the user is expected.
  FTMExperienceEngagementPassive = 1,
/// When the experience is delivered, a prompt is meant to be displayed before presenting
/// the experience.
  FTMExperienceEngagementPrompt = 2,
};

@protocol FTMExperienceManagerDelegate;

/// The experience manager, which communicates experience related activity to its delegate.
SWIFT_CLASS("_TtC7FTMCore20FTMExperienceManager")
@interface FTMExperienceManager : NSObject
/// The delegate.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, weak) id <FTMExperienceManagerDelegate> _Nullable delegate;)
+ (id <FTMExperienceManagerDelegate> _Nullable)delegate SWIFT_WARN_UNUSED_RESULT;
+ (void)setDelegate:(id <FTMExperienceManagerDelegate> _Nullable)value;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A delegate for communicating experience related activity.
SWIFT_PROTOCOL("_TtP7FTMCore28FTMExperienceManagerDelegate_")
@protocol FTMExperienceManagerDelegate
/// Called when one or more experiences are received from the SmartConnect Cloud.
/// When an experience is received, the app should inspect its properties to take the
/// appropriate action. It might be the case that the app is in the background when an
/// experience is received, making it impossible to deliver the expected user interface at that
/// moment. If that happens, persist the experience for later, taking advantage of the fact that
/// <code>FTMExperience</code> conforms to <code>NSSecureCoding</code>. When the app moves to the foreground, the app
/// can then process its persisted experiences.
/// Once an experience has been processed and its intended action has been performed, the app
/// should send an experience conversion to the cloud by calling
/// <code>FTMExperience.sendConversion(action:valueType:value:completion:)</code> or
/// <code>FTMExperience.sendConversion(customActionName:customValueName:value:completion:)</code>
- (void)experienceManagerDidReceiveExperiences:(NSSet<FTMExperience *> * _Nonnull)experiences;
@end

/// The experience types.
/// The custom type is often a good choice since it has no predefined meaning and can handle
/// any situation.
typedef SWIFT_ENUM(NSInteger, FTMExperienceType, closed) {
/// An alert, often paired with <code>FTMExperienceEngagement.prompt</code> for displaying a title and
/// description in something like a <code>UIAlertController</code> or a notification.
  FTMExperienceTypeAlert = 0,
/// An experience with no predefined meaning.
  FTMExperienceTypeCustom = 1,
/// An HTML string.
  FTMExperienceTypeHtml = 2,
/// An image URL.
  FTMExperienceTypeImage = 3,
/// A URL.
  FTMExperienceTypeUrl = 4,
/// A video URL.
  FTMExperienceTypeVideo = 5,
};

/// The type of the value used when sending the conversion.
typedef SWIFT_ENUM(NSInteger, FTMExperienceValueType, closed) {
/// The value represents a currency amount.
  FTMExperienceValueTypeCurrency = 0,
/// The value represents the number of minutes.
  FTMExperienceValueTypeMinutes = 1,
/// The value represents a quantity.
  FTMExperienceValueTypeQuantity = 2,
/// The value represents the number of seconds.
  FTMExperienceValueTypeSeconds = 3,
};

/// The region of the server environment.
typedef SWIFT_ENUM(NSInteger, FTMGlobalRegion, closed) {
/// North America.
  FTMGlobalRegionNorthAmerica = 0,
/// Europe.
  FTMGlobalRegionEurope = 1,
};

@class NFCNDEFMessage;
@class FTMNFCTag;

/// A request that handles the messages of a scanned NFC tag.
SWIFT_CLASS("_TtC7FTMCore27FTMNFCHandleMessagesRequest") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FTMNFCHandleMessagesRequest : NSObject
/// Processes the given NFC NDEF messages.
/// Before calling this method, call <code>canHandleMessages(_:)</code> to check if the messages relate to
/// the SmartConnect platform or not. If they do, call this method to process those messages.
/// If any experiences match the given messages, <code>FTMExperienceManagerDelegate</code> is called to
/// deliver those experiences.
/// \param messages The messages array as provided by <code>NFCNDEFReaderSessionDelegate</code>’s
/// <code>didDetectNDEFs</code> method.
///
/// \param completion The completion handler.
///
///
/// returns:
///
/// A request handle.
+ (FTMRequestHandle * _Nonnull)beginWithMessages:(NSArray<NFCNDEFMessage *> * _Nonnull)messages completion:(void (^ _Nullable)(FTMNFCTag * _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A Footmarks NFC tag.
SWIFT_CLASS("_TtC7FTMCore9FTMNFCTag") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FTMNFCTag : NSObject
/// The attributes configured on the management console.
/// Attributes are a flexible way to specify metadata for an NFC tag.
/// seealso:
///
/// <code>FTMNFCHandleMessagesRequest</code>
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nonnull attributes;
/// The hash value.
@property (nonatomic, readonly) NSUInteger hash;
/// The unique identifier for the NFC tag.
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
/// The name of the NFC tag.
@property (nonatomic, readonly, copy) NSString * _Nonnull name;
/// The URL of the NFC tag.
@property (nonatomic, readonly, copy) NSURL * _Nonnull url;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Allows a nearest beacon acknowledgment to be sent to the SmartConnect Cloud.
SWIFT_CLASS("_TtC7FTMCore30FTMNearestBeaconAcknowledgment")
@interface FTMNearestBeaconAcknowledgment : NSObject
/// Sends an acknowledgment to the SmartConnect Cloud, providing the attribute key and value
/// of the nearest beacon as perceived by the user.
/// In some situations, requesting the nearest beacon may be part of a workflow intended to
/// help the user easily find the nearest beacon. For example, the user might be near three
/// kiosks, each of which is equipped with a beacon, and the app wants to identify the nearest
/// one, such as to streamline the checkout process.
/// In most cases, the SmartConnect Cloud will be able to identify the nearest beacon, but
/// occasionally the user might find the result to be incorrect. The app might provide a user
/// interface that lets the user manually select a different kiosk. In order to train the
/// cloud, it is helpful if the app can send an acknowledgment with attributes that specify
/// which kiosk was in fact the nearest, allowing the cloud to improve results over time.
/// In these cases, the app should send an acknowledgment with the correct attributes,
/// regardless of the result being correct or not. In situations where the app cannot provide
/// meaningful training data to the cloud, an acknowledgment should not be sent.
/// seealso:
///
/// <ul>
///   <li>
///     <code>FTMBeacon.attributes</code>
///   </li>
///   <li>
///     <code>FTMNearestBeaconResult</code>
///   </li>
/// </ul>
/// \param resultID The value of <code>FTMNearestBeaconResult.id</code>
///
/// \param attributeKey The key name in the attributes of the beacon that is nearest according
/// to the user.
///
/// \param attributeValue The value of the key in the attributes of the beacon that is nearest
/// according to the user.
///
/// \param completion The completion handler.
///
+ (FTMRequestHandle * _Nonnull)sendWithResultID:(NSString * _Nonnull)resultID attributeKey:(NSString * _Nonnull)attributeKey attributeValue:(NSString * _Nonnull)attributeValue completion:(void (^ _Nullable)(NSError * _Nullable))completion;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class FTMNearestBeaconResult;

/// A request that returns the beacon nearest to the current device.
SWIFT_CLASS("_TtC7FTMCore23FTMNearestBeaconRequest")
@interface FTMNearestBeaconRequest : NSObject
/// Starts a request that returns the beacon nearest to the current device.
/// If no beacons are present, the result will be <code>nil</code> and there will be no error.
/// \param completion The completion handler.
///
///
/// returns:
///
/// A request handle.
+ (FTMRequestHandle * _Nonnull)beginWithCompletion:(void (^ _Nonnull)(FTMNearestBeaconResult * _Nullable, NSError * _Nullable))completion;
/// Starts a request that returns the beacon nearest to the current device, and that matches
/// the given attribute key and value.
/// A beacon will be returned by the completion handler only if it matches the given attribute
/// key and value. A beacon’s attributes are configured on the management console, and are
/// accessible via <code>FTMBeacon.attributes</code>.
/// If no beacons are present, the result will be <code>nil</code> and there will be no error.
/// seealso:
///
/// <code>FTMBeacon.attributes</code>
/// \param attributeFilterKey A key in a beacon’s attributes dictionary to match on.
///
/// \param attributeFilterValue A value in a beacon’s attributes dictionary to match on.
///
/// \param completion The completion handler.
///
///
/// returns:
///
/// A request handle.
+ (FTMRequestHandle * _Nonnull)beginWithAttributeFilterKey:(NSString * _Nonnull)attributeFilterKey attributeFilterValue:(NSString * _Nonnull)attributeFilterValue completion:(void (^ _Nonnull)(FTMNearestBeaconResult * _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// The result of a request to find the nearest beacon.
/// seealso:
///
/// <ul>
///   <li>
///     <code>FTMNearestBeaconRequest</code>
///   </li>
///   <li>
///     <code>FTMNearestBeaconAcknowledgment</code>
///   </li>
/// </ul>
SWIFT_CLASS("_TtC7FTMCore22FTMNearestBeaconResult")
@interface FTMNearestBeaconResult : NSObject
/// The nearest beacon.
@property (nonatomic, readonly, strong) FTMBeacon * _Nonnull beacon;
/// A value between <code>0.0</code> and <code>1.0</code> representing the confidence level that the given beacon is
/// truly the nearest.
@property (nonatomic, readonly) double confidence;
/// The result ID, used for sending an acknowledgment with <code>FTMNearestBeaconAcknowledgment</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class FTMNearestPeripheralResult;

/// A request that returns the peripheral nearest to the current device.
/// This request is similar to <code>FTMNearestBeaconRequest</code> but works with peripherals instead of
/// beacons. In most cases, a nearest beacon request is best because beacons include more
/// information than peripherals, and some options can be configured in the SmartConnect Cloud.
/// Also not all peripheral functionality is available when the app is running in the background.
/// Otherwise, finding the nearest peripheral has advantages. Peripherals are generally
/// discovered more quickly than beacons, and so finding the nearest one can be faster than
/// finding the nearest beacon.
/// seealso:
///
/// <ul>
///   <li>
///     <code>FTMPeripheral</code>
///   </li>
///   <li>
///     <code>FTMPeripheralManager</code>
///   </li>
/// </ul>
SWIFT_CLASS("_TtC7FTMCore27FTMNearestPeripheralRequest")
@interface FTMNearestPeripheralRequest : NSObject
/// Starts a request that returns the peripheral nearest to the current device.
/// If no peripherals are present, the result will be <code>nil</code> and there will be no error.
/// \param completion The completion handler.
///
///
/// returns:
///
/// A request handle.
+ (FTMRequestHandle * _Nonnull)beginWithCompletion:(void (^ _Nonnull)(FTMNearestPeripheralResult * _Nullable, NSError * _Nullable))completion;
/// Starts a request that returns the peripheral nearest to the current device, and that
/// matches the given attribute key and value.
/// A peripheral will be returned by the completion handler only if it matches the given
/// attribute key and value. A peripheral’s attributes are configured on the management
/// console, and are accessible via <code>FTMPeripheral.attributes</code>.
/// If no peripherals are present, the result will be <code>nil</code> and there will be no error.
/// seealso:
///
/// <code>FTMPeripheral.attributes</code>
/// \param attributeFilterKey A key in a peripheral’s attributes dictionary to match on.
///
/// \param attributeFilterValue A value in a peripheral’s attributes dictionary to match on.
///
/// \param completion The completion handler.
///
///
/// returns:
///
/// A request handle.
+ (FTMRequestHandle * _Nonnull)beginWithAttributeFilterKey:(NSString * _Nonnull)attributeFilterKey attributeFilterValue:(NSString * _Nonnull)attributeFilterValue completion:(void (^ _Nonnull)(FTMNearestPeripheralResult * _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class FTMPeripheral;

/// The result of a request to find the nearest peripheral.
/// seealso:
///
/// <ul>
///   <li>
///     <code>FTMNearestPeripheralRequest</code>
///   </li>
///   <li>
///     <code>FTMNearestBeaconAcknowledgment</code>
///   </li>
/// </ul>
SWIFT_CLASS("_TtC7FTMCore26FTMNearestPeripheralResult")
@interface FTMNearestPeripheralResult : NSObject
/// A value between <code>0.0</code> and <code>1.0</code> representing the confidence level that the given peripheral
/// is truly the nearest.
@property (nonatomic, readonly) double confidence;
/// The result ID, used for sending an acknowledgment with <code>FTMNearestBeaconAcknowledgment</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
/// The nearest peripheral.
@property (nonatomic, readonly, strong) FTMPeripheral * _Nonnull peripheral;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A Footmarks peripheral.
/// A peripheral is essentially a lightweight beacon that doesn’t include all of the properites
/// of a normal beacon.
/// seealso:
///
/// <ul>
///   <li>
///     <code>FTMNearestPeripheralRequest</code>
///   </li>
///   <li>
///     <code>FTMPeripheralManager</code>
///   </li>
/// </ul>
SWIFT_CLASS("_TtC7FTMCore13FTMPeripheral")
@interface FTMPeripheral : NSObject
/// The accuracy of the underlying peripheral.
@property (nonatomic, readonly) CLLocationAccuracy accuracy;
/// The attributes configured on the management console.
/// Attributes are a flexible way to specify metadata for a peripheral. They can be used as
/// filters when finding the nearest peripheral.
/// seealso:
///
/// <code>FTMNearestPeripheralRequest.begin(attributeFilterKey:attributeFilterValue:completion:)</code>
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nonnull attributes;
/// The hash value.
@property (nonatomic, readonly) NSUInteger hash;
/// The unique identifier for the peripheral.
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
/// The MAC address.
@property (nonatomic, readonly, copy) NSString * _Nonnull macAddress;
/// The RSSI value of the underlying peripheral.
@property (nonatomic, readonly) NSInteger rssi;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The peripheral manager, which maintains a list of in-range peripherals.
/// seealso:
///
/// <ul>
///   <li>
///     <code>FTMNearestPeripheralRequest</code>
///   </li>
///   <li>
///     <code>FTMPeripheral</code>
///   </li>
/// </ul>
SWIFT_CLASS("_TtC7FTMCore20FTMPeripheralManager")
@interface FTMPeripheralManager : NSObject
/// All peripherals that are in range of the current device.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSSet<FTMPeripheral *> * _Nonnull peripherals;)
+ (NSSet<FTMPeripheral *> * _Nonnull)peripherals SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A handle returned by a network request, allowing the request to be canceled.
/// Network requests follow a completion handler pattern that makes it easy to take action once
/// a request has finished. When creating a request, a handle is returned to the caller.
/// It is not necessary to use or make a strong reference to a handle. The network request will
/// continue until it has completed. To cancel a request, call <code>cancel()</code> on its handle.
SWIFT_CLASS("_TtC7FTMCore16FTMRequestHandle")
@interface FTMRequestHandle : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Cancels the network request associated with the handle.
/// It is harmless to cancel the same request more than once.
- (void)cancel;
@end


/// A request that sends a remote notifications device token to the SmartConnect Cloud.
/// The SmartConnect platform supports sending push notifications. To enable this in your
/// application, follow Apple’s guide for “Configuring Remote Notification Support.” One important
/// step is to receive a device token in the application delegate’s
/// <code>didRegisterForRemoteNotificationsWithDeviceToken</code> callback method. The token received should
/// be passed to this request.
SWIFT_CLASS("_TtC7FTMCore23FTMSendPushTokenRequest")
@interface FTMSendPushTokenRequest : NSObject
/// Starts a request that sends a remote notifications device token to the SmartConnect Cloud.
/// \param deviceToken The token from the application delegate’s
/// <code>didRegisterForRemoteNotificationsWithDeviceToken</code> callback method.
///
/// \param completion The completion handler.
///
///
/// returns:
///
/// A request handle.
+ (FTMRequestHandle * _Nonnull)beginWithDeviceToken:(NSData * _Nonnull)deviceToken completion:(void (^ _Nullable)(NSError * _Nullable))completion;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A class for managing a session with the SmartConnect Cloud.
SWIFT_CLASS("_TtC7FTMCore10FTMSession")
@interface FTMSession : NSObject
/// Whether or not a session is active.
/// After a successful call to <code>signIn(appKey:appSecret:globalRegion:username:completion:)</code>,
/// a session will be established and this property will return <code>true</code>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL isSignedIn;)
+ (BOOL)isSignedIn SWIFT_WARN_UNUSED_RESULT;
/// Deletes the data associated with the current session from the SmartConnect Cloud,
/// then signs out.
/// If the request completes without error, there will no longer be an active session, and
/// beacon management will come to a halt. To start managing beacons again, call
/// <code>signIn(appKey:appSecret:globalRegion:username:completion:)</code>
/// \param completion The completion handler.
///
///
/// returns:
///
/// A request handle.
+ (FTMRequestHandle * _Nonnull)deleteSessionAndUserDataWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Signs in to establish a session with the SmartConnect Cloud.
/// \param appKey The app key.
///
/// \param appSecret The app secret.
///
/// \param globalRegion The global region.
///
/// \param username An optional username to associate with the session. This can be any
/// arbitrary identifier.
///
/// \param completion The completion handler.
///
///
/// returns:
///
/// A request handle.
+ (FTMRequestHandle * _Nonnull)signInWithAppKey:(NSString * _Nonnull)appKey appSecret:(NSString * _Nonnull)appSecret globalRegion:(enum FTMGlobalRegion)globalRegion username:(NSString * _Nullable)username completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Signs out the current session.
/// Signing out causes beacon management to come to a halt. To start managing beacons again,
/// call <code>signIn(appKey:appSecret:globalRegion:username:completion:)</code>
+ (void)signOut;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif

#elif defined(__ARM_ARCH_7A__) && __ARM_ARCH_7A__
// Generated by Apple Swift version 5.3 (swiftlang-1200.0.29.2 clang-1200.0.30.1)
#ifndef FTMCORE_SWIFT_H
#define FTMCORE_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreBluetooth;
@import CoreLocation;
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="FTMCore",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif


/// A Footmarks beacon.
SWIFT_CLASS("_TtC7FTMCore9FTMBeacon")
@interface FTMBeacon : NSObject
/// The accuracy of the underlying <code>CLBeacon</code>.
@property (nonatomic, readonly) CLLocationAccuracy accuracy;
/// The attributes configured on the management console.
/// Attributes are a flexible way to specify metadata for a beacon. They can be used as
/// filters when finding the nearest beacon.
/// seealso:
///
/// <code>FTMNearestBeaconRequest.begin(attributeFilterKey:attributeFilterValue:completion:)</code>
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nonnull attributes;
/// The hash value.
@property (nonatomic, readonly) NSUInteger hash;
/// The unique identifier for the beacon.
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
/// The MAC address.
@property (nonatomic, readonly, copy) NSString * _Nonnull macAddress;
/// The name of the beacon.
/// Generally the name will be the same as the beacon’s <code>macAddress</code>, although beacon names
/// can be customized on the management console.
@property (nonatomic, readonly, copy) NSString * _Nonnull name;
/// The proximity of the underlying <code>CLBeacon</code>.
@property (nonatomic, readonly) CLProximity proximity;
/// The RSSI value of the underlying <code>CLBeacon</code>.
@property (nonatomic, readonly) NSInteger rssi;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@protocol FTMBeaconManagerDelegate;

/// The beacon manager, which maintains a list of in-range beacons and communicates state changes
/// with its delegate.
SWIFT_CLASS("_TtC7FTMCore16FTMBeaconManager")
@interface FTMBeaconManager : NSObject
/// All beacons that are in range of the current device.
/// When entering a region, one or more beacons are added to the set, and when exiting a region
/// they are removed. Changes can be monitoried by implementing
/// <code>FTMBeaconManagerDelegate.beaconManagerDidRangeBeacons()</code>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSSet<FTMBeacon *> * _Nonnull beacons;)
+ (NSSet<FTMBeacon *> * _Nonnull)beacons SWIFT_WARN_UNUSED_RESULT;
/// The state of the underlying <code>CBCentralManager</code>.
/// Changes can be monitoried by implementing
/// <code>FTMBeaconManagerDelegate.beaconManagerDidUpdateCentralManagerState()</code>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) CBManagerState centralManagerState;)
+ (CBManagerState)centralManagerState SWIFT_WARN_UNUSED_RESULT;
/// The delegate.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, weak) id <FTMBeaconManagerDelegate> _Nullable delegate;)
+ (id <FTMBeaconManagerDelegate> _Nullable)delegate SWIFT_WARN_UNUSED_RESULT;
+ (void)setDelegate:(id <FTMBeaconManagerDelegate> _Nullable)value;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// A delegate for communicating beacon related updates and state changes.
SWIFT_PROTOCOL("_TtP7FTMCore24FTMBeaconManagerDelegate_")
@protocol FTMBeaconManagerDelegate
@optional
/// Called when the underlying <code>CLLocationManager</code> changes its authorization status.
/// Call <code>CLLocationManager.authorizationStatus()</code> to retrieve the status. An app might update
/// its user interface in response to a status change, for example.
- (void)beaconManagerDidChangeLocationManagerAuthorizationStatus;
@required
/// Called when the beacon manager experiences an error.
/// If the error’s domain matches <code>FTMError.domain</code>, the error code can be comapred to one of
/// the <code>FTMError</code> enumeration values.
- (void)beaconManagerDidFailWithError:(NSError * _Nonnull)error;
/// Called when the beacon manager updates its beacons.
/// Beacons are updated when entering a region, when idling within in a region, and when exiting
/// a region. The latest beacons are available by calling <code>FTMBeaconManager.beacons</code>.
- (void)beaconManagerDidRangeBeacons;
@optional
/// Called when the underlying <code>CBCentralManager</code> updates its state.
/// Call <code>FTMBeaconManager.centralManagerState</code> to retrieve the state. An app might update
/// its user interface in response to a state change, for example.
- (void)beaconManagerDidUpdateCentralManagerState;
@end

/// An enumeration of error codes associated with errors returned by the framework.
typedef SWIFT_ENUM(NSInteger, FTMError, closed) {
/// The app key or secret is missing from
/// <code>FTMSession.signIn(appKey:appSecret:globalRegion:username:completion:)</code>
  FTMErrorAppKeyOrSecretMissing = 0,
/// Authorization failed during a network request.
  FTMErrorAuthFailed = 1,
/// The required <code>NSBluetoothAlwaysUsageDescription</code> key is missing from the app’s
/// plist file.
  FTMErrorBluetoothAlwaysUsageDescriptionMissing = 2,
/// The required <code>NSBluetoothPeripheralUsageDescription</code> key is missing from the app’s
/// plist file.
  FTMErrorBluetoothPeripheralUsageDescriptionMissing = 3,
/// The NFC messages can’t be handled.
  FTMErrorCannotHandleNFCMessages = 4,
/// The required <code>NSLocationAlwaysAndWhenInUseUsageDescription</code> key is missing from the app’s
/// plist file.
  FTMErrorLocationAlwaysAndWhenInUseUsageDescriptionMissing = 5,
/// The required <code>NSLocationAlwaysUsageDescription</code> key is missing from the app’s plist file.
  FTMErrorLocationAlwaysUsageDescriptionMissing = 6,
/// The use of location services has not been granted.
  FTMErrorLocationServicesDenied = 7,
/// Location services are disabled.
  FTMErrorLocationServicesDisabled = 8,
/// The required <code>NSLocationWhenInUseUsageDescription</code> key is missing from the app’s plist file.
  FTMErrorLocationWhenInUseUsageDescriptionMissing = 9,
/// A parameter has an invalid value.
  FTMErrorParameter = 10,
/// A miscellaneous error occurred while making a network request.
  FTMErrorWebServiceGeneric = 11,
};

enum FTMExperienceEngagement : NSInteger;
enum FTMExperienceType : NSInteger;
@class NSCoder;
enum FTMExperienceAction : NSInteger;
enum FTMExperienceValueType : NSInteger;
@class FTMRequestHandle;

/// An experience configured in the SmartConnect Cloud.
SWIFT_CLASS("_TtC7FTMCore13FTMExperience")
@interface FTMExperience : NSObject <NSSecureCoding>
/// The attributes of the payload as configured on the management console.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nonnull attributes;
/// The content of the experience.
/// The nature of the content depends on the experience type.
/// <ul>
///   <li>
///     alert: (unused)
///   </li>
///   <li>
///     custom: Any custom value
///   </li>
///   <li>
///     html: The HTML
///   </li>
///   <li>
///     image: The image URL
///   </li>
///   <li>
///     url: The URL
///   </li>
///   <li>
///     video: The video URL
///   </li>
/// </ul>
@property (nonatomic, readonly, copy) NSString * _Nonnull content;
/// The type of engagement to have with the user.
@property (nonatomic, readonly) enum FTMExperienceEngagement engagement;
/// The type of experience.
@property (nonatomic, readonly) enum FTMExperienceType experienceType;
/// The hash value.
@property (nonatomic, readonly) NSUInteger hash;
/// The name of the payload as configured on the management console.
@property (nonatomic, readonly, copy) NSString * _Nonnull name;
/// The description when <code>engagement</code> is of type <code>prompt</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull promptDescription;
/// The title when <code>engagement</code> is of type <code>prompt</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull promptTitle;
/// Supports secure coding.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
+ (void)setSupportsSecureCoding:(BOOL)value;
/// Creates an experience using the given unarchiver.
/// \param decoder An unarchiver object.
///
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder;
/// Encodes the experience using the given archiver.
/// \param encoder An archiver object.
///
- (void)encodeWithCoder:(NSCoder * _Nonnull)encoder;
/// Sends a conversion to the SmartConnect Cloud to acknowledge that the experience has been
/// received and processed.
/// \param action The action that was taken.
///
/// \param valueType The type of the value.
///
/// \param value The value associated with the conversion.
///
/// \param completion The completion handler.
///
///
/// returns:
///
/// A request handle.
- (FTMRequestHandle * _Nonnull)sendConversionWithAction:(enum FTMExperienceAction)action valueType:(enum FTMExperienceValueType)valueType value:(double)value completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Sends a conversion to the SmartConnect Cloud to acknowledge that the experience has been
/// received and processed.
/// \param customActionName The name of the custom action that was taken.
///
/// \param customValueName The name of the custom value.
///
/// \param value The value associated with the conversion.
///
/// \param completion The completion handler.
///
///
/// returns:
///
/// A request handle.
- (FTMRequestHandle * _Nonnull)sendConversionWithCustomActionName:(NSString * _Nonnull)customActionName customValueName:(NSString * _Nonnull)customValueName value:(double)value completion:(void (^ _Nullable)(NSError * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// The action taken for the experience conversion.
typedef SWIFT_ENUM(NSInteger, FTMExperienceAction, closed) {
/// The conversion happened automatically.
  FTMExperienceActionAutomated = 0,
/// The content was tapped or clicked.
  FTMExperienceActionClicked = 1,
/// The content was listened to.
  FTMExperienceActionListened = 2,
/// No action was taken.
  FTMExperienceActionNone = 3,
/// The content was opened.
  FTMExperienceActionOpened = 4,
/// The content was retargeted.
  FTMExperienceActionRetargeted = 5,
/// The content was shared.
  FTMExperienceActionShared = 6,
/// The content was swiped.
  FTMExperienceActionSwiped = 7,
/// The content was watched.
  FTMExperienceActionWatched = 8,
};

/// The engatement types for experiences.
typedef SWIFT_ENUM(NSInteger, FTMExperienceEngagement, closed) {
/// When the experience is delivered, it is meant to be presented immediately.
  FTMExperienceEngagementAutoShow = 0,
/// When the experience is delivered, no engagement with the user is expected.
  FTMExperienceEngagementPassive = 1,
/// When the experience is delivered, a prompt is meant to be displayed before presenting
/// the experience.
  FTMExperienceEngagementPrompt = 2,
};

@protocol FTMExperienceManagerDelegate;

/// The experience manager, which communicates experience related activity to its delegate.
SWIFT_CLASS("_TtC7FTMCore20FTMExperienceManager")
@interface FTMExperienceManager : NSObject
/// The delegate.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, weak) id <FTMExperienceManagerDelegate> _Nullable delegate;)
+ (id <FTMExperienceManagerDelegate> _Nullable)delegate SWIFT_WARN_UNUSED_RESULT;
+ (void)setDelegate:(id <FTMExperienceManagerDelegate> _Nullable)value;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A delegate for communicating experience related activity.
SWIFT_PROTOCOL("_TtP7FTMCore28FTMExperienceManagerDelegate_")
@protocol FTMExperienceManagerDelegate
/// Called when one or more experiences are received from the SmartConnect Cloud.
/// When an experience is received, the app should inspect its properties to take the
/// appropriate action. It might be the case that the app is in the background when an
/// experience is received, making it impossible to deliver the expected user interface at that
/// moment. If that happens, persist the experience for later, taking advantage of the fact that
/// <code>FTMExperience</code> conforms to <code>NSSecureCoding</code>. When the app moves to the foreground, the app
/// can then process its persisted experiences.
/// Once an experience has been processed and its intended action has been performed, the app
/// should send an experience conversion to the cloud by calling
/// <code>FTMExperience.sendConversion(action:valueType:value:completion:)</code> or
/// <code>FTMExperience.sendConversion(customActionName:customValueName:value:completion:)</code>
- (void)experienceManagerDidReceiveExperiences:(NSSet<FTMExperience *> * _Nonnull)experiences;
@end

/// The experience types.
/// The custom type is often a good choice since it has no predefined meaning and can handle
/// any situation.
typedef SWIFT_ENUM(NSInteger, FTMExperienceType, closed) {
/// An alert, often paired with <code>FTMExperienceEngagement.prompt</code> for displaying a title and
/// description in something like a <code>UIAlertController</code> or a notification.
  FTMExperienceTypeAlert = 0,
/// An experience with no predefined meaning.
  FTMExperienceTypeCustom = 1,
/// An HTML string.
  FTMExperienceTypeHtml = 2,
/// An image URL.
  FTMExperienceTypeImage = 3,
/// A URL.
  FTMExperienceTypeUrl = 4,
/// A video URL.
  FTMExperienceTypeVideo = 5,
};

/// The type of the value used when sending the conversion.
typedef SWIFT_ENUM(NSInteger, FTMExperienceValueType, closed) {
/// The value represents a currency amount.
  FTMExperienceValueTypeCurrency = 0,
/// The value represents the number of minutes.
  FTMExperienceValueTypeMinutes = 1,
/// The value represents a quantity.
  FTMExperienceValueTypeQuantity = 2,
/// The value represents the number of seconds.
  FTMExperienceValueTypeSeconds = 3,
};

/// The region of the server environment.
typedef SWIFT_ENUM(NSInteger, FTMGlobalRegion, closed) {
/// North America.
  FTMGlobalRegionNorthAmerica = 0,
/// Europe.
  FTMGlobalRegionEurope = 1,
};

@class NFCNDEFMessage;
@class FTMNFCTag;

/// A request that handles the messages of a scanned NFC tag.
SWIFT_CLASS("_TtC7FTMCore27FTMNFCHandleMessagesRequest") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FTMNFCHandleMessagesRequest : NSObject
/// Processes the given NFC NDEF messages.
/// Before calling this method, call <code>canHandleMessages(_:)</code> to check if the messages relate to
/// the SmartConnect platform or not. If they do, call this method to process those messages.
/// If any experiences match the given messages, <code>FTMExperienceManagerDelegate</code> is called to
/// deliver those experiences.
/// \param messages The messages array as provided by <code>NFCNDEFReaderSessionDelegate</code>’s
/// <code>didDetectNDEFs</code> method.
///
/// \param completion The completion handler.
///
///
/// returns:
///
/// A request handle.
+ (FTMRequestHandle * _Nonnull)beginWithMessages:(NSArray<NFCNDEFMessage *> * _Nonnull)messages completion:(void (^ _Nullable)(FTMNFCTag * _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A Footmarks NFC tag.
SWIFT_CLASS("_TtC7FTMCore9FTMNFCTag") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FTMNFCTag : NSObject
/// The attributes configured on the management console.
/// Attributes are a flexible way to specify metadata for an NFC tag.
/// seealso:
///
/// <code>FTMNFCHandleMessagesRequest</code>
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nonnull attributes;
/// The hash value.
@property (nonatomic, readonly) NSUInteger hash;
/// The unique identifier for the NFC tag.
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
/// The name of the NFC tag.
@property (nonatomic, readonly, copy) NSString * _Nonnull name;
/// The URL of the NFC tag.
@property (nonatomic, readonly, copy) NSURL * _Nonnull url;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Allows a nearest beacon acknowledgment to be sent to the SmartConnect Cloud.
SWIFT_CLASS("_TtC7FTMCore30FTMNearestBeaconAcknowledgment")
@interface FTMNearestBeaconAcknowledgment : NSObject
/// Sends an acknowledgment to the SmartConnect Cloud, providing the attribute key and value
/// of the nearest beacon as perceived by the user.
/// In some situations, requesting the nearest beacon may be part of a workflow intended to
/// help the user easily find the nearest beacon. For example, the user might be near three
/// kiosks, each of which is equipped with a beacon, and the app wants to identify the nearest
/// one, such as to streamline the checkout process.
/// In most cases, the SmartConnect Cloud will be able to identify the nearest beacon, but
/// occasionally the user might find the result to be incorrect. The app might provide a user
/// interface that lets the user manually select a different kiosk. In order to train the
/// cloud, it is helpful if the app can send an acknowledgment with attributes that specify
/// which kiosk was in fact the nearest, allowing the cloud to improve results over time.
/// In these cases, the app should send an acknowledgment with the correct attributes,
/// regardless of the result being correct or not. In situations where the app cannot provide
/// meaningful training data to the cloud, an acknowledgment should not be sent.
/// seealso:
///
/// <ul>
///   <li>
///     <code>FTMBeacon.attributes</code>
///   </li>
///   <li>
///     <code>FTMNearestBeaconResult</code>
///   </li>
/// </ul>
/// \param resultID The value of <code>FTMNearestBeaconResult.id</code>
///
/// \param attributeKey The key name in the attributes of the beacon that is nearest according
/// to the user.
///
/// \param attributeValue The value of the key in the attributes of the beacon that is nearest
/// according to the user.
///
/// \param completion The completion handler.
///
+ (FTMRequestHandle * _Nonnull)sendWithResultID:(NSString * _Nonnull)resultID attributeKey:(NSString * _Nonnull)attributeKey attributeValue:(NSString * _Nonnull)attributeValue completion:(void (^ _Nullable)(NSError * _Nullable))completion;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class FTMNearestBeaconResult;

/// A request that returns the beacon nearest to the current device.
SWIFT_CLASS("_TtC7FTMCore23FTMNearestBeaconRequest")
@interface FTMNearestBeaconRequest : NSObject
/// Starts a request that returns the beacon nearest to the current device.
/// If no beacons are present, the result will be <code>nil</code> and there will be no error.
/// \param completion The completion handler.
///
///
/// returns:
///
/// A request handle.
+ (FTMRequestHandle * _Nonnull)beginWithCompletion:(void (^ _Nonnull)(FTMNearestBeaconResult * _Nullable, NSError * _Nullable))completion;
/// Starts a request that returns the beacon nearest to the current device, and that matches
/// the given attribute key and value.
/// A beacon will be returned by the completion handler only if it matches the given attribute
/// key and value. A beacon’s attributes are configured on the management console, and are
/// accessible via <code>FTMBeacon.attributes</code>.
/// If no beacons are present, the result will be <code>nil</code> and there will be no error.
/// seealso:
///
/// <code>FTMBeacon.attributes</code>
/// \param attributeFilterKey A key in a beacon’s attributes dictionary to match on.
///
/// \param attributeFilterValue A value in a beacon’s attributes dictionary to match on.
///
/// \param completion The completion handler.
///
///
/// returns:
///
/// A request handle.
+ (FTMRequestHandle * _Nonnull)beginWithAttributeFilterKey:(NSString * _Nonnull)attributeFilterKey attributeFilterValue:(NSString * _Nonnull)attributeFilterValue completion:(void (^ _Nonnull)(FTMNearestBeaconResult * _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// The result of a request to find the nearest beacon.
/// seealso:
///
/// <ul>
///   <li>
///     <code>FTMNearestBeaconRequest</code>
///   </li>
///   <li>
///     <code>FTMNearestBeaconAcknowledgment</code>
///   </li>
/// </ul>
SWIFT_CLASS("_TtC7FTMCore22FTMNearestBeaconResult")
@interface FTMNearestBeaconResult : NSObject
/// The nearest beacon.
@property (nonatomic, readonly, strong) FTMBeacon * _Nonnull beacon;
/// A value between <code>0.0</code> and <code>1.0</code> representing the confidence level that the given beacon is
/// truly the nearest.
@property (nonatomic, readonly) double confidence;
/// The result ID, used for sending an acknowledgment with <code>FTMNearestBeaconAcknowledgment</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class FTMNearestPeripheralResult;

/// A request that returns the peripheral nearest to the current device.
/// This request is similar to <code>FTMNearestBeaconRequest</code> but works with peripherals instead of
/// beacons. In most cases, a nearest beacon request is best because beacons include more
/// information than peripherals, and some options can be configured in the SmartConnect Cloud.
/// Also not all peripheral functionality is available when the app is running in the background.
/// Otherwise, finding the nearest peripheral has advantages. Peripherals are generally
/// discovered more quickly than beacons, and so finding the nearest one can be faster than
/// finding the nearest beacon.
/// seealso:
///
/// <ul>
///   <li>
///     <code>FTMPeripheral</code>
///   </li>
///   <li>
///     <code>FTMPeripheralManager</code>
///   </li>
/// </ul>
SWIFT_CLASS("_TtC7FTMCore27FTMNearestPeripheralRequest")
@interface FTMNearestPeripheralRequest : NSObject
/// Starts a request that returns the peripheral nearest to the current device.
/// If no peripherals are present, the result will be <code>nil</code> and there will be no error.
/// \param completion The completion handler.
///
///
/// returns:
///
/// A request handle.
+ (FTMRequestHandle * _Nonnull)beginWithCompletion:(void (^ _Nonnull)(FTMNearestPeripheralResult * _Nullable, NSError * _Nullable))completion;
/// Starts a request that returns the peripheral nearest to the current device, and that
/// matches the given attribute key and value.
/// A peripheral will be returned by the completion handler only if it matches the given
/// attribute key and value. A peripheral’s attributes are configured on the management
/// console, and are accessible via <code>FTMPeripheral.attributes</code>.
/// If no peripherals are present, the result will be <code>nil</code> and there will be no error.
/// seealso:
///
/// <code>FTMPeripheral.attributes</code>
/// \param attributeFilterKey A key in a peripheral’s attributes dictionary to match on.
///
/// \param attributeFilterValue A value in a peripheral’s attributes dictionary to match on.
///
/// \param completion The completion handler.
///
///
/// returns:
///
/// A request handle.
+ (FTMRequestHandle * _Nonnull)beginWithAttributeFilterKey:(NSString * _Nonnull)attributeFilterKey attributeFilterValue:(NSString * _Nonnull)attributeFilterValue completion:(void (^ _Nonnull)(FTMNearestPeripheralResult * _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class FTMPeripheral;

/// The result of a request to find the nearest peripheral.
/// seealso:
///
/// <ul>
///   <li>
///     <code>FTMNearestPeripheralRequest</code>
///   </li>
///   <li>
///     <code>FTMNearestBeaconAcknowledgment</code>
///   </li>
/// </ul>
SWIFT_CLASS("_TtC7FTMCore26FTMNearestPeripheralResult")
@interface FTMNearestPeripheralResult : NSObject
/// A value between <code>0.0</code> and <code>1.0</code> representing the confidence level that the given peripheral
/// is truly the nearest.
@property (nonatomic, readonly) double confidence;
/// The result ID, used for sending an acknowledgment with <code>FTMNearestBeaconAcknowledgment</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
/// The nearest peripheral.
@property (nonatomic, readonly, strong) FTMPeripheral * _Nonnull peripheral;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A Footmarks peripheral.
/// A peripheral is essentially a lightweight beacon that doesn’t include all of the properites
/// of a normal beacon.
/// seealso:
///
/// <ul>
///   <li>
///     <code>FTMNearestPeripheralRequest</code>
///   </li>
///   <li>
///     <code>FTMPeripheralManager</code>
///   </li>
/// </ul>
SWIFT_CLASS("_TtC7FTMCore13FTMPeripheral")
@interface FTMPeripheral : NSObject
/// The accuracy of the underlying peripheral.
@property (nonatomic, readonly) CLLocationAccuracy accuracy;
/// The attributes configured on the management console.
/// Attributes are a flexible way to specify metadata for a peripheral. They can be used as
/// filters when finding the nearest peripheral.
/// seealso:
///
/// <code>FTMNearestPeripheralRequest.begin(attributeFilterKey:attributeFilterValue:completion:)</code>
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nonnull attributes;
/// The hash value.
@property (nonatomic, readonly) NSUInteger hash;
/// The unique identifier for the peripheral.
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
/// The MAC address.
@property (nonatomic, readonly, copy) NSString * _Nonnull macAddress;
/// The RSSI value of the underlying peripheral.
@property (nonatomic, readonly) NSInteger rssi;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The peripheral manager, which maintains a list of in-range peripherals.
/// seealso:
///
/// <ul>
///   <li>
///     <code>FTMNearestPeripheralRequest</code>
///   </li>
///   <li>
///     <code>FTMPeripheral</code>
///   </li>
/// </ul>
SWIFT_CLASS("_TtC7FTMCore20FTMPeripheralManager")
@interface FTMPeripheralManager : NSObject
/// All peripherals that are in range of the current device.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSSet<FTMPeripheral *> * _Nonnull peripherals;)
+ (NSSet<FTMPeripheral *> * _Nonnull)peripherals SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A handle returned by a network request, allowing the request to be canceled.
/// Network requests follow a completion handler pattern that makes it easy to take action once
/// a request has finished. When creating a request, a handle is returned to the caller.
/// It is not necessary to use or make a strong reference to a handle. The network request will
/// continue until it has completed. To cancel a request, call <code>cancel()</code> on its handle.
SWIFT_CLASS("_TtC7FTMCore16FTMRequestHandle")
@interface FTMRequestHandle : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Cancels the network request associated with the handle.
/// It is harmless to cancel the same request more than once.
- (void)cancel;
@end


/// A request that sends a remote notifications device token to the SmartConnect Cloud.
/// The SmartConnect platform supports sending push notifications. To enable this in your
/// application, follow Apple’s guide for “Configuring Remote Notification Support.” One important
/// step is to receive a device token in the application delegate’s
/// <code>didRegisterForRemoteNotificationsWithDeviceToken</code> callback method. The token received should
/// be passed to this request.
SWIFT_CLASS("_TtC7FTMCore23FTMSendPushTokenRequest")
@interface FTMSendPushTokenRequest : NSObject
/// Starts a request that sends a remote notifications device token to the SmartConnect Cloud.
/// \param deviceToken The token from the application delegate’s
/// <code>didRegisterForRemoteNotificationsWithDeviceToken</code> callback method.
///
/// \param completion The completion handler.
///
///
/// returns:
///
/// A request handle.
+ (FTMRequestHandle * _Nonnull)beginWithDeviceToken:(NSData * _Nonnull)deviceToken completion:(void (^ _Nullable)(NSError * _Nullable))completion;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A class for managing a session with the SmartConnect Cloud.
SWIFT_CLASS("_TtC7FTMCore10FTMSession")
@interface FTMSession : NSObject
/// Whether or not a session is active.
/// After a successful call to <code>signIn(appKey:appSecret:globalRegion:username:completion:)</code>,
/// a session will be established and this property will return <code>true</code>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL isSignedIn;)
+ (BOOL)isSignedIn SWIFT_WARN_UNUSED_RESULT;
/// Deletes the data associated with the current session from the SmartConnect Cloud,
/// then signs out.
/// If the request completes without error, there will no longer be an active session, and
/// beacon management will come to a halt. To start managing beacons again, call
/// <code>signIn(appKey:appSecret:globalRegion:username:completion:)</code>
/// \param completion The completion handler.
///
///
/// returns:
///
/// A request handle.
+ (FTMRequestHandle * _Nonnull)deleteSessionAndUserDataWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Signs in to establish a session with the SmartConnect Cloud.
/// \param appKey The app key.
///
/// \param appSecret The app secret.
///
/// \param globalRegion The global region.
///
/// \param username An optional username to associate with the session. This can be any
/// arbitrary identifier.
///
/// \param completion The completion handler.
///
///
/// returns:
///
/// A request handle.
+ (FTMRequestHandle * _Nonnull)signInWithAppKey:(NSString * _Nonnull)appKey appSecret:(NSString * _Nonnull)appSecret globalRegion:(enum FTMGlobalRegion)globalRegion username:(NSString * _Nullable)username completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Signs out the current session.
/// Signing out causes beacon management to come to a halt. To start managing beacons again,
/// call <code>signIn(appKey:appSecret:globalRegion:username:completion:)</code>
+ (void)signOut;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif

#endif
